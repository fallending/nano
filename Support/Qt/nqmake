#!/usr/bin/ruby -w
#============================================================================
#	NAME:
#		nqmake
#
#	DESCRIPTION:
#		Nano-aware wrapper around Qt's qmake.
#	
#	COPYRIGHT:
#		Copyright (c) 2009, refNum Software
#		<http://www.refnum.com/>
#
#		All rights reserved.
#============================================================================
#		Imports
#----------------------------------------------------------------------------





#============================================================================
#		XCProject : Xcode project object.
#----------------------------------------------------------------------------
class XCProject
	#========================================================================
	#		initialize : Initializer.
	#------------------------------------------------------------------------
	def initialize(qtProject)
	
		# Check our parameters
		raise("Unable to find .pro") if qtProject.nil?;
		
		
		
		# Initialise ourselves
		projectName  = File.basename(qtProject).sub(".pro", ".xcodeproj");
		@projectPath = File.dirname(qtProject) + "/" + projectName + "/project.pbxproj";

	end





	#========================================================================
	#		loadProject : Load the project.
	#------------------------------------------------------------------------
	def loadProject()
	
		# Load the project
		@projectState = IO.read(@projectPath);
			@projectState.gsub!(/\\"/,       '__QUOTE__');
			@projectState.gsub!(/(".*?")/m,   '\'\1\'');
			@projectState.gsub!('__QUOTE__', '\\"');

			@projectState.gsub!(" = ", " => ");
			@projectState.gsub!(";",   ",");

			@projectState.gsub!("(", "[");
			@projectState.gsub!(")", "]");

			@projectState.gsub!(/(\w+) =/,  '"\1" =');
			@projectState.gsub!(/=> ([^'].*[^']),/, '=> \'\1\',');

			@projectState.sub!('// !$*UTF8*$!', "@projectState = ");
		eval(@projectState);

	end





	#========================================================================
	#		saveProject : Save the project.
	#------------------------------------------------------------------------
	def saveProject
	
		# Save the project
		theProject = "// !$*UTF8*$!\n";
		theProject += flattenHash(1, @projectState);
		
		File.open(@projectPath, 'w') {|theFile| theFile.write(theProject) }
		
		# dair
		puts theProject;
		
	end





	#========================================================================
	#		modifyBuildMake : Modify the makefile build phase.
	#------------------------------------------------------------------------
	def modifyBuildMake
	
		# Replace absolute paths
		#
		# qmake uses absolute paths for its shell script phases.
		#
		# These can be turned into relative paths from PROJECT_DIR, allowing the
		# project to be checked into source control and shared between developers.
		findObjects("PBXShellScriptBuildPhase") do |theID, theState|

			if (theState["shellScript"] != nil):
				theState["shellScript"].sub!(Dir.getwd, '$PROJECT_DIR');
			end

		end
	
	end





	#========================================================================
	#		modifyBuildCopy : Modify the copy build phase.
	#------------------------------------------------------------------------
	def modifyBuildCopy
	
		# Get the state we need
		theIDs = Array.new;


		# Identify the copy build phase
		#
		# qmake generates a build phase which copies the app into the same
		# directory as the .pro file.
		#
		# Since this area is under source control, we remove this step to let
		# deveopers use the Xcode build products preference to control where
		# the output is placed.
		findObjects("PBXCopyFilesBuildPhase") do |theID, theState|

			theState["files"].each do |fileID|
				theIDs.push(dequoteValue(fileID));
			end
		
			theIDs.push(theID);
		end


		# Remove the build phase
		removeObjects(theIDs);
	
	end





	#========================================================================
	#		modifyProjectRoot : Modify the project root.
	#------------------------------------------------------------------------
	def modifyProjectRoot
	
		# Set the project root
		#
		# qmake does not generate a projectRoot value for the project.
		#
		# This causes Xcode 3 to prompt the user for this value whe the project
		# is first opened, so we define it for them.
		findObjects("PBXProject") do |theID, theState|
			theState["projectRoot"] = '""';
		end
	
	end





	#========================================================================
	#		modifyProjectPList : Modify the project Info.plist.
	#------------------------------------------------------------------------
	def modifyProjectPList
	
		# Adjust the project
		#
		# qmake generates a template Info.plist in the project directory.
		#
		# We replace this with a custom Info.plist in the Resources directory.
		findObjects("PBXNativeTarget") do |theID, theState|
			theState["buildSettings"]["INFOPLIST_FILE"] = '"../Resources/Info.plist"';
			theState.delete("productSettingsXML");
		end
		
		
		
		# Remove the qmake file
		File.unlink(Dir.getwd + "/Info.plist");

	end





	#========================================================================
	#		findObjects : Find objects of a given type.
	#------------------------------------------------------------------------
	def findObjects(theType)

		# Walk the objects
		@projectState["objects"].each_pair do |theKey, theValue|

			if (theValue["isa"] == theType):
				yield(theKey, theValue);
			end

		end
	
	end





	#========================================================================
	#		removeObjects : Remove objects.
	#------------------------------------------------------------------------
	def removeObjects(theIDs)
	
		# Remove the objects
		theIDs.each do |theID|
			@projectState["objects"].delete(theID);
		end
	
	end





	#========================================================================
	#        objectID : Create a unique object ID.
	#------------------------------------------------------------------------
	def objectID

		loop do
			theID = (0...12).map { '%02X' % rand(256) }.join;
			if (! @projectState["objects"].has_key?(theID)):
				return(theID);
			end
		end

	end





	#========================================================================
	#		flattenHash : Flatten a hash.
	#------------------------------------------------------------------------
	def flattenHash(theIndent, theHash)
	
		# Get the state we need
		theResult = "{\n"
		thePrefix = Array.new(theIndent, "\t").join();



		# Flatten the hash
		theHash.each_pair do |theKey, theValue|
			theResult += thePrefix + "#{theKey} = ";
			
			if theValue.is_a?(Array):
				theResult += flattenArray(theIndent+1, theValue);
			
			elsif theValue.is_a?(Hash):
				theResult += flattenHash(theIndent+1,  theValue);
			
			else
				theResult += enquoteValue(theValue);
			end
			
			theResult += ";\n";
		end
		
		
		
		# Close the value
		theResult += thePrefix.chop() + "}"

		return(theResult);

	end





	#========================================================================
	#		flattenArray : Flatten an array.
	#------------------------------------------------------------------------
	def flattenArray(theIndent, theArray)
	
		# Get the state we need
		theResult = "(\n"
		thePrefix = Array.new(theIndent, "\t").join();



		# Flatten the array
		theArray.each do |theValue|
			theResult += thePrefix;
			
			if theValue.is_a?(Array):
				theResult += flattenArray(theIndent+1, theValue);
			
			elsif theValue.is_a?(Hash):
				theResult += flattenHash(theIndent+1,  theValue);
			
			else
				theResult += enquoteValue(theValue);
			end
			
			theResult += ",\n";
		end
		
		
		
		# Close the value
		theResult += "\n" if theResult.chomp!(",\n");
		theResult += thePrefix.chop() + ")"

		return(theResult);

	end





	#========================================================================
	#        enquoteValue : Enquote a value.
	#------------------------------------------------------------------------
	def enquoteValue(theValue)

		return("#{theValue}");
	
	end





	#========================================================================
	#        dequoteValue : Dequote a value.
	#------------------------------------------------------------------------
	def dequoteValue(theValue)

		if (theValue =~ /"(.*)"/):
			theValue = $1;
		end
		
		return(theValue);
	
	end

end





#============================================================================
#		findQtProject : Find the Qt project.
#----------------------------------------------------------------------------
def findQtProject

	# Check the command line
	if (ARGV.last != nil):
		return(ARGV.last);
	end



	# Or search for a file
	thePath = Dir.getwd + "/*.pro";
	thePath = Dir[thePath].first;
	
	return(thePath);

end





#============================================================================
#		createProject : Create the project.
#----------------------------------------------------------------------------
def createProject

	# Create the project
	#
	# qmake is silent if successful, so we halt on any output.
	theErr = `qmake #{ ARGV.join(' ') } 2>&1`.chomp;
	if !theErr.empty?:
		puts theErr + "\n";
		exit;
	end

end





#============================================================================
#		updateProject : Update the project.
#----------------------------------------------------------------------------
def updateProject

	# Get the state we need
	qtProject = findQtProject();
	xcProject = XCProject.new(qtProject);



	# Update the project
	xcProject.loadProject();
	xcProject.modifyBuildMake();
	xcProject.modifyBuildCopy();
	xcProject.modifyProjectRoot();
	xcProject.modifyProjectPList();
	xcProject.saveProject();

end





#============================================================================
#		nqmake : Nano qmake.
#----------------------------------------------------------------------------
createProject();
updateProject();

